(ns cljc.java-time.local-date-time (:require [cljs.java-time.interop :as jti] #? (:cljs [java.time :refer [LocalDateTime]])) (:refer-clojure :exclude [get range format min max next name resolve]) #? (:clj (:import [java.time LocalDateTime])))
(def max (. java.time.LocalDateTime -MAX))
(def min (. java.time.LocalDateTime -MIN))
(clojure.core/defn minus-minutes {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this1956 ^long long1957] (.minusMinutes this1956 long1957)))
(clojure.core/defn truncated-to {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalUnit"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this1958 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit1959] (.truncatedTo this1958 java-time-temporal-TemporalUnit1959)))
(clojure.core/defn minus-weeks {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this1960 ^long long1961] (.minusWeeks this1960 long1961)))
(clojure.core/defn to-instant {:arglists (quote (["java.time.LocalDateTime" "java.time.ZoneOffset"]))} (^java.time.Instant [^java.time.LocalDateTime this1962 ^java.time.ZoneOffset java-time-ZoneOffset1963] (.toInstant this1962 java-time-ZoneOffset1963)))
(clojure.core/defn plus-weeks {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this1964 ^long long1965] (.plusWeeks this1964 long1965)))
(clojure.core/defn range {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.LocalDateTime this1966 ^java.time.temporal.TemporalField java-time-temporal-TemporalField1967] (.range this1966 java-time-temporal-TemporalField1967)))
(clojure.core/defn of-epoch-second {:arglists (quote (["java.time.LocalDateTime" "long" "int" "java.time.ZoneOffset"]))} (^java.time.LocalDateTime [^long long1968 ^java.lang.Integer int1969 ^java.time.ZoneOffset java-time-ZoneOffset1970] (. java.time.LocalDateTime ofEpochSecond long1968 int1969 java-time-ZoneOffset1970)))
(clojure.core/defn get-hour {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this1971] (jti/getter hour this1971)))
(clojure.core/defn at-offset {:arglists (quote (["java.time.LocalDateTime" "java.time.ZoneOffset"]))} (^java.time.OffsetDateTime [^java.time.LocalDateTime this1972 ^java.time.ZoneOffset java-time-ZoneOffset1973] (.atOffset this1972 java-time-ZoneOffset1973)))
(clojure.core/defn minus-hours {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this1974 ^long long1975] (.minusHours this1974 long1975)))
(clojure.core/defn of {:arglists (quote (["java.time.LocalDateTime" "int" "int" "int" "int" "int" "int"] ["java.time.LocalDateTime" "int" "int" "int" "int" "int"] ["java.time.LocalDateTime" "int" "java.time.Month" "int" "int" "int" "int" "int"] ["java.time.LocalDateTime" "int" "java.time.Month" "int" "int" "int" "int"] ["java.time.LocalDateTime" "int" "java.time.Month" "int" "int" "int"] ["java.time.LocalDateTime" "java.time.LocalDate" "java.time.LocalTime"] ["java.time.LocalDateTime" "int" "int" "int" "int" "int" "int" "int"]))} (^java.time.LocalDateTime [G__1977 G__1978 G__1979 G__1980 G__1981 G__1982] #? (:cljs (. java.time.LocalDateTime of G__1977 G__1978 G__1979 G__1980 G__1981 G__1982) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1977) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1978) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1979) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1980) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1981) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1982)) (clojure.core/let [G__1977 ^"java.lang.Integer" G__1977 G__1978 ^"java.lang.Integer" G__1978 G__1979 ^"java.lang.Integer" G__1979 G__1980 ^"java.lang.Integer" G__1980 G__1981 ^"java.lang.Integer" G__1981 G__1982 ^"java.lang.Integer" G__1982] (. java.time.LocalDateTime of G__1977 G__1978 G__1979 G__1980 G__1981 G__1982)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1977) (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__1978) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1979) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1980) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1981) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1982)) (clojure.core/let [G__1977 ^"java.lang.Integer" G__1977 G__1978 ^"java.time.Month" G__1978 G__1979 ^"java.lang.Integer" G__1979 G__1980 ^"java.lang.Integer" G__1980 G__1981 ^"java.lang.Integer" G__1981 G__1982 ^"java.lang.Integer" G__1982] (. java.time.LocalDateTime of G__1977 G__1978 G__1979 G__1980 G__1981 G__1982)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.time.LocalDateTime [G__1984 G__1985 G__1986 G__1987 G__1988] #? (:cljs (. java.time.LocalDateTime of G__1984 G__1985 G__1986 G__1987 G__1988) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1984) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1985) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1986) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1987) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1988)) (clojure.core/let [G__1984 ^"java.lang.Integer" G__1984 G__1985 ^"java.lang.Integer" G__1985 G__1986 ^"java.lang.Integer" G__1986 G__1987 ^"java.lang.Integer" G__1987 G__1988 ^"java.lang.Integer" G__1988] (. java.time.LocalDateTime of G__1984 G__1985 G__1986 G__1987 G__1988)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1984) (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__1985) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1986) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1987) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1988)) (clojure.core/let [G__1984 ^"java.lang.Integer" G__1984 G__1985 ^"java.time.Month" G__1985 G__1986 ^"java.lang.Integer" G__1986 G__1987 ^"java.lang.Integer" G__1987 G__1988 ^"java.lang.Integer" G__1988] (. java.time.LocalDateTime of G__1984 G__1985 G__1986 G__1987 G__1988)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.time.LocalDateTime [G__1990 G__1991 G__1992 G__1993 G__1994 G__1995 G__1996] #? (:cljs (. java.time.LocalDateTime of G__1990 G__1991 G__1992 G__1993 G__1994 G__1995 G__1996) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1990) (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__1991) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1992) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1993) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1994) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1995) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1996)) (clojure.core/let [G__1990 ^"java.lang.Integer" G__1990 G__1991 ^"java.time.Month" G__1991 G__1992 ^"java.lang.Integer" G__1992 G__1993 ^"java.lang.Integer" G__1993 G__1994 ^"java.lang.Integer" G__1994 G__1995 ^"java.lang.Integer" G__1995 G__1996 ^"java.lang.Integer" G__1996] (. java.time.LocalDateTime of G__1990 G__1991 G__1992 G__1993 G__1994 G__1995 G__1996)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1990) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1991) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1992) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1993) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1994) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1995) (clojure.core/instance? (java.lang.Class/forName "java.lang.Integer") G__1996)) (clojure.core/let [G__1990 ^"java.lang.Integer" G__1990 G__1991 ^"java.lang.Integer" G__1991 G__1992 ^"java.lang.Integer" G__1992 G__1993 ^"java.lang.Integer" G__1993 G__1994 ^"java.lang.Integer" G__1994 G__1995 ^"java.lang.Integer" G__1995 G__1996 ^"java.lang.Integer" G__1996] (. java.time.LocalDateTime of G__1990 G__1991 G__1992 G__1993 G__1994 G__1995 G__1996)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.time.LocalDateTime [^java.time.LocalDate java-time-LocalDate1997 ^java.time.LocalTime java-time-LocalTime1998] (. java.time.LocalDateTime of java-time-LocalDate1997 java-time-LocalTime1998)))
(clojure.core/defn with-month {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this1999 ^java.lang.Integer int2000] (.withMonth this1999 int2000)))
(clojure.core/defn is-equal {:arglists (quote (["java.time.LocalDateTime" "java.time.chrono.ChronoLocalDateTime"]))} (^java.lang.Boolean [^java.time.LocalDateTime this2001 ^java.time.chrono.ChronoLocalDateTime java-time-chrono-ChronoLocalDateTime2002] (.isEqual this2001 java-time-chrono-ChronoLocalDateTime2002)))
(clojure.core/defn get-nano {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this2003] (jti/getter nano this2003)))
(clojure.core/defn get-year {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this2004] (jti/getter year this2004)))
(clojure.core/defn minus-seconds {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2005 ^long long2006] (.minusSeconds this2005 long2006)))
(clojure.core/defn get-second {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this2007] (jti/getter second this2007)))
(clojure.core/defn plus-nanos {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2008 ^long long2009] (.plusNanos this2008 long2009)))
(clojure.core/defn get-day-of-year {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this2010] (jti/getter dayOfYear this2010)))
(clojure.core/defn plus {:arglists (quote (["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this2011 G__2012 G__2013] #? (:cljs (.plus ^java.time.LocalDateTime this2011 G__2012 G__2013) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2012) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2013)) (clojure.core/let [G__2012 (clojure.core/long G__2012) G__2013 ^"java.time.temporal.TemporalUnit" G__2013] (.plus ^java.time.LocalDateTime this2011 G__2012 G__2013)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2012) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2013)) (clojure.core/let [G__2012 (clojure.core/long G__2012) G__2013 ^"java.time.temporal.TemporalUnit" G__2013] (.plus ^java.time.LocalDateTime this2011 G__2012 G__2013)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2012) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2013)) (clojure.core/let [G__2012 (clojure.core/long G__2012) G__2013 ^"java.time.temporal.TemporalUnit" G__2013] (.plus ^java.time.LocalDateTime this2011 G__2012 G__2013)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this2014 G__2015] #? (:cljs (.plus ^java.time.LocalDateTime this2014 G__2015) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2015)) (clojure.core/let [G__2015 ^"java.time.temporal.TemporalAmount" G__2015] (.plus ^java.time.LocalDateTime this2014 G__2015)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2015)) (clojure.core/let [G__2015 ^"java.time.temporal.TemporalAmount" G__2015] (.plus ^java.time.LocalDateTime this2014 G__2015)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2015)) (clojure.core/let [G__2015 ^"java.time.temporal.TemporalAmount" G__2015] (.plus ^java.time.LocalDateTime this2014 G__2015)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn with-hour {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2016 ^java.lang.Integer int2017] (.withHour this2016 int2017)))
(clojure.core/defn with-minute {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2018 ^java.lang.Integer int2019] (.withMinute this2018 int2019)))
(clojure.core/defn plus-minutes {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2020 ^long long2021] (.plusMinutes this2020 long2021)))
(clojure.core/defn query {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.LocalDateTime this2022 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery2023] (.query this2022 java-time-temporal-TemporalQuery2023)))
(clojure.core/defn get-day-of-week {:arglists (quote (["java.time.LocalDateTime"]))} (^java.time.DayOfWeek [^java.time.LocalDateTime this2024] (jti/getter dayOfWeek this2024)))
(clojure.core/defn to-string {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.String [^java.time.LocalDateTime this2025] (.toString this2025)))
(clojure.core/defn plus-months {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2026 ^long long2027] (.plusMonths this2026 long2027)))
(clojure.core/defn is-before {:arglists (quote (["java.time.LocalDateTime" "java.time.chrono.ChronoLocalDateTime"]))} (^java.lang.Boolean [^java.time.LocalDateTime this2028 ^java.time.chrono.ChronoLocalDateTime java-time-chrono-ChronoLocalDateTime2029] (.isBefore this2028 java-time-chrono-ChronoLocalDateTime2029)))
(clojure.core/defn minus-months {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2030 ^long long2031] (.minusMonths this2030 long2031)))
(clojure.core/defn minus {:arglists (quote (["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this2032 G__2033 G__2034] #? (:cljs (.minus ^java.time.LocalDateTime this2032 G__2033 G__2034) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2033) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2034)) (clojure.core/let [G__2033 (clojure.core/long G__2033) G__2034 ^"java.time.temporal.TemporalUnit" G__2034] (.minus ^java.time.LocalDateTime this2032 G__2033 G__2034)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2033) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2034)) (clojure.core/let [G__2033 (clojure.core/long G__2033) G__2034 ^"java.time.temporal.TemporalUnit" G__2034] (.minus ^java.time.LocalDateTime this2032 G__2033 G__2034)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2033) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2034)) (clojure.core/let [G__2033 (clojure.core/long G__2033) G__2034 ^"java.time.temporal.TemporalUnit" G__2034] (.minus ^java.time.LocalDateTime this2032 G__2033 G__2034)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this2035 G__2036] #? (:cljs (.minus ^java.time.LocalDateTime this2035 G__2036) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2036)) (clojure.core/let [G__2036 ^"java.time.temporal.TemporalAmount" G__2036] (.minus ^java.time.LocalDateTime this2035 G__2036)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2036)) (clojure.core/let [G__2036 ^"java.time.temporal.TemporalAmount" G__2036] (.minus ^java.time.LocalDateTime this2035 G__2036)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2036)) (clojure.core/let [G__2036 ^"java.time.temporal.TemporalAmount" G__2036] (.minus ^java.time.LocalDateTime this2035 G__2036)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn at-zone {:arglists (quote (["java.time.LocalDateTime" "java.time.ZoneId"] ["java.time.LocalDateTime" "java.time.ZoneId"]))} (^java.lang.Object [this2037 G__2038] #? (:cljs (.atZone ^java.time.LocalDateTime this2037 G__2038) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__2038)) (clojure.core/let [G__2038 ^"java.time.ZoneId" G__2038] (.atZone ^java.time.LocalDateTime this2037 G__2038)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__2038)) (clojure.core/let [G__2038 ^"java.time.ZoneId" G__2038] (.atZone ^java.time.LocalDateTime this2037 G__2038)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn plus-hours {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2039 ^long long2040] (.plusHours this2039 long2040)))
(clojure.core/defn plus-days {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2041 ^long long2042] (.plusDays this2041 long2042)))
(clojure.core/defn to-local-time {:arglists (quote (["java.time.LocalDateTime"]))} (^java.time.LocalTime [^java.time.LocalDateTime this2043] (.toLocalTime this2043)))
(clojure.core/defn get-long {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalField"]))} (^long [^java.time.LocalDateTime this2044 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2045] (.getLong this2044 java-time-temporal-TemporalField2045)))
(clojure.core/defn with-year {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2046 ^java.lang.Integer int2047] (.withYear this2046 int2047)))
(clojure.core/defn with-nano {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2048 ^java.lang.Integer int2049] (.withNano this2048 int2049)))
(clojure.core/defn to-epoch-second {:arglists (quote (["java.time.LocalDateTime" "java.time.ZoneOffset"]))} (^long [^java.time.LocalDateTime this2050 ^java.time.ZoneOffset java-time-ZoneOffset2051] (.toEpochSecond this2050 java-time-ZoneOffset2051)))
(clojure.core/defn until {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.LocalDateTime this2052 ^java.time.temporal.Temporal java-time-temporal-Temporal2053 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit2054] (.until this2052 java-time-temporal-Temporal2053 java-time-temporal-TemporalUnit2054)))
(clojure.core/defn with-day-of-month {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2055 ^java.lang.Integer int2056] (.withDayOfMonth this2055 int2056)))
(clojure.core/defn get-day-of-month {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this2057] (jti/getter dayOfMonth this2057)))
(clojure.core/defn from {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalAccessor"]))} (^java.time.LocalDateTime [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor2058] (. java.time.LocalDateTime from java-time-temporal-TemporalAccessor2058)))
(clojure.core/defn is-after {:arglists (quote (["java.time.LocalDateTime" "java.time.chrono.ChronoLocalDateTime"]))} (^java.lang.Boolean [^java.time.LocalDateTime this2059 ^java.time.chrono.ChronoLocalDateTime java-time-chrono-ChronoLocalDateTime2060] (.isAfter this2059 java-time-chrono-ChronoLocalDateTime2060)))
(clojure.core/defn minus-nanos {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2061 ^long long2062] (.minusNanos this2061 long2062)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalField"] ["java.time.LocalDateTime" "java.time.temporal.TemporalUnit"]))} (^java.lang.Boolean [this2063 G__2064] #? (:cljs (.isSupported ^java.time.LocalDateTime this2063 G__2064) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2064)) (clojure.core/let [G__2064 ^"java.time.temporal.TemporalField" G__2064] (.isSupported ^java.time.LocalDateTime this2063 G__2064)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2064)) (clojure.core/let [G__2064 ^"java.time.temporal.TemporalUnit" G__2064] (.isSupported ^java.time.LocalDateTime this2063 G__2064)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn minus-years {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2065 ^long long2066] (.minusYears this2065 long2066)))
(clojure.core/defn get-chronology {:arglists (quote (["java.time.LocalDateTime"]))} (^java.time.chrono.Chronology [^java.time.LocalDateTime this2067] (jti/getter chronology this2067)))
(clojure.core/defn parse {:arglists (quote (["java.time.LocalDateTime" "java.lang.CharSequence" "java.time.format.DateTimeFormatter"] ["java.time.LocalDateTime" "java.lang.CharSequence"]))} (^java.time.LocalDateTime [^java.lang.CharSequence java-lang-CharSequence2068 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter2069] (. java.time.LocalDateTime parse java-lang-CharSequence2068 java-time-format-DateTimeFormatter2069)) (^java.time.LocalDateTime [^java.lang.CharSequence java-lang-CharSequence2070] (. java.time.LocalDateTime parse java-lang-CharSequence2070)))
(clojure.core/defn with-second {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2071 ^java.lang.Integer int2072] (.withSecond this2071 int2072)))
(clojure.core/defn to-local-date {:arglists (quote (["java.time.LocalDateTime"] ["java.time.LocalDateTime"]))} (^java.lang.Object [this2073] #? (:cljs (.toLocalDate ^java.time.LocalDateTime this2073) :clj (clojure.core/cond (clojure.core/and) (clojure.core/let [] (.toLocalDate ^java.time.LocalDateTime this2073)) (clojure.core/and) (clojure.core/let [] (.toLocalDate ^java.time.LocalDateTime this2073)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn get-minute {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this2074] (jti/getter minute this2074)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this2075] (.hashCode this2075)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.LocalDateTime this2076 ^java.time.temporal.Temporal java-time-temporal-Temporal2077] (.adjustInto this2076 java-time-temporal-Temporal2077)))
(clojure.core/defn with {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalAdjuster"] ["java.time.LocalDateTime" "java.time.temporal.TemporalField" "long"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAdjuster"] ["java.time.LocalDateTime" "java.time.temporal.TemporalField" "long"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAdjuster"] ["java.time.LocalDateTime" "java.time.temporal.TemporalField" "long"]))} (^java.lang.Object [this2078 G__2079] #? (:cljs (.with ^java.time.LocalDateTime this2078 G__2079) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__2079)) (clojure.core/let [G__2079 ^"java.time.temporal.TemporalAdjuster" G__2079] (.with ^java.time.LocalDateTime this2078 G__2079)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__2079)) (clojure.core/let [G__2079 ^"java.time.temporal.TemporalAdjuster" G__2079] (.with ^java.time.LocalDateTime this2078 G__2079)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__2079)) (clojure.core/let [G__2079 ^"java.time.temporal.TemporalAdjuster" G__2079] (.with ^java.time.LocalDateTime this2078 G__2079)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this2080 G__2081 G__2082] #? (:cljs (.with ^java.time.LocalDateTime this2080 G__2081 G__2082) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2081) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2082)) (clojure.core/let [G__2081 ^"java.time.temporal.TemporalField" G__2081 G__2082 (clojure.core/long G__2082)] (.with ^java.time.LocalDateTime this2080 G__2081 G__2082)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2081) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2082)) (clojure.core/let [G__2081 ^"java.time.temporal.TemporalField" G__2081 G__2082 (clojure.core/long G__2082)] (.with ^java.time.LocalDateTime this2080 G__2081 G__2082)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2081) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2082)) (clojure.core/let [G__2081 ^"java.time.temporal.TemporalField" G__2081 G__2082 (clojure.core/long G__2082)] (.with ^java.time.LocalDateTime this2080 G__2081 G__2082)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn now {:arglists (quote (["java.time.LocalDateTime"] ["java.time.LocalDateTime" "java.time.ZoneId"] ["java.time.LocalDateTime" "java.time.Clock"]))} (^java.time.LocalDateTime [] (. java.time.LocalDateTime now)) (^java.time.LocalDateTime [G__2084] #? (:cljs (. java.time.LocalDateTime now G__2084) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__2084)) (clojure.core/let [G__2084 ^"java.time.ZoneId" G__2084] (. java.time.LocalDateTime now G__2084)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__2084)) (clojure.core/let [G__2084 ^"java.time.Clock" G__2084] (. java.time.LocalDateTime now G__2084)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn get-month-value {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this2085] (jti/getter monthValue this2085)))
(clojure.core/defn with-day-of-year {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2086 ^java.lang.Integer int2087] (.withDayOfYear this2086 int2087)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.LocalDateTime" "java.lang.Object"] ["java.time.LocalDateTime" "java.time.chrono.ChronoLocalDateTime"]))} (^java.lang.Integer [this2088 G__2089] #? (:cljs (.compareTo ^java.time.LocalDateTime this2088 G__2089) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__2089)) (clojure.core/let [G__2089 ^"java.lang.Object" G__2089] (.compareTo ^java.time.LocalDateTime this2088 G__2089)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.chrono.ChronoLocalDateTime") G__2089)) (clojure.core/let [G__2089 ^"java.time.chrono.ChronoLocalDateTime" G__2089] (.compareTo ^java.time.LocalDateTime this2088 G__2089)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn get-month {:arglists (quote (["java.time.LocalDateTime"]))} (^java.time.Month [^java.time.LocalDateTime this2090] (jti/getter month this2090)))
(clojure.core/defn of-instant {:arglists (quote (["java.time.LocalDateTime" "java.time.Instant" "java.time.ZoneId"]))} (^java.time.LocalDateTime [^java.time.Instant java-time-Instant2091 ^java.time.ZoneId java-time-ZoneId2092] (. java.time.LocalDateTime ofInstant java-time-Instant2091 java-time-ZoneId2092)))
(clojure.core/defn plus-seconds {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2093 ^long long2094] (.plusSeconds this2093 long2094)))
(clojure.core/defn get {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.LocalDateTime this2095 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2096] (.get this2095 java-time-temporal-TemporalField2096)))
(clojure.core/defn equals {:arglists (quote (["java.time.LocalDateTime" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.LocalDateTime this2097 ^java.lang.Object java-lang-Object2098] (.equals this2097 java-lang-Object2098)))
(clojure.core/defn format {:arglists (quote (["java.time.LocalDateTime" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.LocalDateTime this2099 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter2100] (.format this2099 java-time-format-DateTimeFormatter2100)))
(clojure.core/defn plus-years {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2101 ^long long2102] (.plusYears this2101 long2102)))
(clojure.core/defn minus-days {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this2103 ^long long2104] (.minusDays this2103 long2104)))
