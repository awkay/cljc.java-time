(ns cljc.java-time.local-time (:require [cljs.java-time.interop :as jti] #? (:cljs [java.time :refer [LocalTime]])) (:refer-clojure :exclude [get range format min max next name resolve]) #? (:clj (:import [java.time LocalTime])))
(def max (. java.time.LocalTime -MAX))
(def noon (. java.time.LocalTime -NOON))
(def midnight (. java.time.LocalTime -MIDNIGHT))
(def min (. java.time.LocalTime -MIN))
(clojure.core/defn minus-minutes {:arglists (quote (["java.time.LocalTime" "long"]))} (^java.time.LocalTime [^java.time.LocalTime this2652 ^long long2653] (.minusMinutes this2652 long2653)))
(clojure.core/defn truncated-to {:arglists (quote (["java.time.LocalTime" "java.time.temporal.TemporalUnit"]))} (^java.time.LocalTime [^java.time.LocalTime this2654 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit2655] (.truncatedTo this2654 java-time-temporal-TemporalUnit2655)))
(clojure.core/defn range {:arglists (quote (["java.time.LocalTime" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.LocalTime this2656 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2657] (.range this2656 java-time-temporal-TemporalField2657)))
(clojure.core/defn get-hour {:arglists (quote (["java.time.LocalTime"]))} (^java.lang.Integer [^java.time.LocalTime this2658] (jti/getter hour this2658)))
(clojure.core/defn at-offset {:arglists (quote (["java.time.LocalTime" "java.time.ZoneOffset"]))} (^java.time.OffsetTime [^java.time.LocalTime this2659 ^java.time.ZoneOffset java-time-ZoneOffset2660] (.atOffset this2659 java-time-ZoneOffset2660)))
(clojure.core/defn minus-hours {:arglists (quote (["java.time.LocalTime" "long"]))} (^java.time.LocalTime [^java.time.LocalTime this2661 ^long long2662] (.minusHours this2661 long2662)))
(clojure.core/defn of {:arglists (quote (["int" "int"] ["int" "int" "int"] ["int" "int" "int" "int"]))} (^java.time.LocalTime [^java.lang.Integer int2663 ^java.lang.Integer int2664] (. java.time.LocalTime of int2663 int2664)) (^java.time.LocalTime [^java.lang.Integer int2665 ^java.lang.Integer int2666 ^java.lang.Integer int2667] (. java.time.LocalTime of int2665 int2666 int2667)) (^java.time.LocalTime [^java.lang.Integer int2668 ^java.lang.Integer int2669 ^java.lang.Integer int2670 ^java.lang.Integer int2671] (. java.time.LocalTime of int2668 int2669 int2670 int2671)))
(clojure.core/defn get-nano {:arglists (quote (["java.time.LocalTime"]))} (^java.lang.Integer [^java.time.LocalTime this2672] (jti/getter nano this2672)))
(clojure.core/defn minus-seconds {:arglists (quote (["java.time.LocalTime" "long"]))} (^java.time.LocalTime [^java.time.LocalTime this2673 ^long long2674] (.minusSeconds this2673 long2674)))
(clojure.core/defn get-second {:arglists (quote (["java.time.LocalTime"]))} (^java.lang.Integer [^java.time.LocalTime this2675] (jti/getter second this2675)))
(clojure.core/defn plus-nanos {:arglists (quote (["java.time.LocalTime" "long"]))} (^java.time.LocalTime [^java.time.LocalTime this2676 ^long long2677] (.plusNanos this2676 long2677)))
(clojure.core/defn plus {:arglists (quote (["java.time.LocalTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalTime" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this2678 G__2679] #? (:cljs (.plus ^java.time.LocalTime this2678 G__2679) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2679)) (clojure.core/let [G__2679 ^"java.time.temporal.TemporalAmount" G__2679] (.plus ^java.time.LocalTime this2678 G__2679)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2679)) (clojure.core/let [G__2679 ^"java.time.temporal.TemporalAmount" G__2679] (.plus ^java.time.LocalTime this2678 G__2679)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this2680 G__2681 G__2682] #? (:cljs (.plus ^java.time.LocalTime this2680 G__2681 G__2682) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2681) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2682)) (clojure.core/let [G__2681 (clojure.core/long G__2681) G__2682 ^"java.time.temporal.TemporalUnit" G__2682] (.plus ^java.time.LocalTime this2680 G__2681 G__2682)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2681) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2682)) (clojure.core/let [G__2681 (clojure.core/long G__2681) G__2682 ^"java.time.temporal.TemporalUnit" G__2682] (.plus ^java.time.LocalTime this2680 G__2681 G__2682)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn with-hour {:arglists (quote (["java.time.LocalTime" "int"]))} (^java.time.LocalTime [^java.time.LocalTime this2683 ^java.lang.Integer int2684] (.withHour this2683 int2684)))
(clojure.core/defn with-minute {:arglists (quote (["java.time.LocalTime" "int"]))} (^java.time.LocalTime [^java.time.LocalTime this2685 ^java.lang.Integer int2686] (.withMinute this2685 int2686)))
(clojure.core/defn plus-minutes {:arglists (quote (["java.time.LocalTime" "long"]))} (^java.time.LocalTime [^java.time.LocalTime this2687 ^long long2688] (.plusMinutes this2687 long2688)))
(clojure.core/defn query {:arglists (quote (["java.time.LocalTime" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.LocalTime this2689 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery2690] (.query this2689 java-time-temporal-TemporalQuery2690)))
(clojure.core/defn at-date {:arglists (quote (["java.time.LocalTime" "java.time.LocalDate"]))} (^java.time.LocalDateTime [^java.time.LocalTime this2691 ^java.time.LocalDate java-time-LocalDate2692] (.atDate this2691 java-time-LocalDate2692)))
(clojure.core/defn to-string {:arglists (quote (["java.time.LocalTime"]))} (^java.lang.String [^java.time.LocalTime this2693] (.toString this2693)))
(clojure.core/defn is-before {:arglists (quote (["java.time.LocalTime" "java.time.LocalTime"]))} (^java.lang.Boolean [^java.time.LocalTime this2694 ^java.time.LocalTime java-time-LocalTime2695] (.isBefore this2694 java-time-LocalTime2695)))
(clojure.core/defn minus {:arglists (quote (["java.time.LocalTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalTime" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this2696 G__2697 G__2698] #? (:cljs (.minus ^java.time.LocalTime this2696 G__2697 G__2698) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2697) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2698)) (clojure.core/let [G__2697 (clojure.core/long G__2697) G__2698 ^"java.time.temporal.TemporalUnit" G__2698] (.minus ^java.time.LocalTime this2696 G__2697 G__2698)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2697) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2698)) (clojure.core/let [G__2697 (clojure.core/long G__2697) G__2698 ^"java.time.temporal.TemporalUnit" G__2698] (.minus ^java.time.LocalTime this2696 G__2697 G__2698)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this2699 G__2700] #? (:cljs (.minus ^java.time.LocalTime this2699 G__2700) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2700)) (clojure.core/let [G__2700 ^"java.time.temporal.TemporalAmount" G__2700] (.minus ^java.time.LocalTime this2699 G__2700)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2700)) (clojure.core/let [G__2700 ^"java.time.temporal.TemporalAmount" G__2700] (.minus ^java.time.LocalTime this2699 G__2700)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn plus-hours {:arglists (quote (["java.time.LocalTime" "long"]))} (^java.time.LocalTime [^java.time.LocalTime this2701 ^long long2702] (.plusHours this2701 long2702)))
(clojure.core/defn to-second-of-day {:arglists (quote (["java.time.LocalTime"]))} (^java.lang.Integer [^java.time.LocalTime this2703] (.toSecondOfDay this2703)))
(clojure.core/defn get-long {:arglists (quote (["java.time.LocalTime" "java.time.temporal.TemporalField"]))} (^long [^java.time.LocalTime this2704 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2705] (.getLong this2704 java-time-temporal-TemporalField2705)))
(clojure.core/defn with-nano {:arglists (quote (["java.time.LocalTime" "int"]))} (^java.time.LocalTime [^java.time.LocalTime this2706 ^java.lang.Integer int2707] (.withNano this2706 int2707)))
(clojure.core/defn until {:arglists (quote (["java.time.LocalTime" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.LocalTime this2708 ^java.time.temporal.Temporal java-time-temporal-Temporal2709 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit2710] (.until this2708 java-time-temporal-Temporal2709 java-time-temporal-TemporalUnit2710)))
(clojure.core/defn of-nano-of-day {:arglists (quote (["long"]))} (^java.time.LocalTime [^long long2711] (. java.time.LocalTime ofNanoOfDay long2711)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.LocalTime [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor2712] (. java.time.LocalTime from java-time-temporal-TemporalAccessor2712)))
(clojure.core/defn is-after {:arglists (quote (["java.time.LocalTime" "java.time.LocalTime"]))} (^java.lang.Boolean [^java.time.LocalTime this2713 ^java.time.LocalTime java-time-LocalTime2714] (.isAfter this2713 java-time-LocalTime2714)))
(clojure.core/defn minus-nanos {:arglists (quote (["java.time.LocalTime" "long"]))} (^java.time.LocalTime [^java.time.LocalTime this2715 ^long long2716] (.minusNanos this2715 long2716)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.LocalTime" "java.time.temporal.TemporalField"] ["java.time.LocalTime" "java.time.temporal.TemporalUnit"]))} (^java.lang.Boolean [this2717 G__2718] #? (:cljs (.isSupported ^java.time.LocalTime this2717 G__2718) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2718)) (clojure.core/let [G__2718 ^"java.time.temporal.TemporalField" G__2718] (.isSupported ^java.time.LocalTime this2717 G__2718)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2718)) (clojure.core/let [G__2718 ^"java.time.temporal.TemporalUnit" G__2718] (.isSupported ^java.time.LocalTime this2717 G__2718)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence" "java.time.format.DateTimeFormatter"] ["java.lang.CharSequence"]))} (^java.time.LocalTime [^java.lang.CharSequence java-lang-CharSequence2719 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter2720] (. java.time.LocalTime parse java-lang-CharSequence2719 java-time-format-DateTimeFormatter2720)) (^java.time.LocalTime [^java.lang.CharSequence java-lang-CharSequence2721] (. java.time.LocalTime parse java-lang-CharSequence2721)))
(clojure.core/defn with-second {:arglists (quote (["java.time.LocalTime" "int"]))} (^java.time.LocalTime [^java.time.LocalTime this2722 ^java.lang.Integer int2723] (.withSecond this2722 int2723)))
(clojure.core/defn get-minute {:arglists (quote (["java.time.LocalTime"]))} (^java.lang.Integer [^java.time.LocalTime this2724] (jti/getter minute this2724)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.LocalTime"]))} (^java.lang.Integer [^java.time.LocalTime this2725] (.hashCode this2725)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.LocalTime" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.LocalTime this2726 ^java.time.temporal.Temporal java-time-temporal-Temporal2727] (.adjustInto this2726 java-time-temporal-Temporal2727)))
(clojure.core/defn with {:arglists (quote (["java.time.LocalTime" "java.time.temporal.TemporalField" "long"] ["java.time.LocalTime" "java.time.temporal.TemporalAdjuster"] ["java.time.LocalTime" "java.time.temporal.TemporalAdjuster"] ["java.time.LocalTime" "java.time.temporal.TemporalField" "long"]))} (^java.lang.Object [this2728 G__2729 G__2730] #? (:cljs (.with ^java.time.LocalTime this2728 G__2729 G__2730) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2729) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2730)) (clojure.core/let [G__2729 ^"java.time.temporal.TemporalField" G__2729 G__2730 (clojure.core/long G__2730)] (.with ^java.time.LocalTime this2728 G__2729 G__2730)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2729) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2730)) (clojure.core/let [G__2729 ^"java.time.temporal.TemporalField" G__2729 G__2730 (clojure.core/long G__2730)] (.with ^java.time.LocalTime this2728 G__2729 G__2730)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this2731 G__2732] #? (:cljs (.with ^java.time.LocalTime this2731 G__2732) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__2732)) (clojure.core/let [G__2732 ^"java.time.temporal.TemporalAdjuster" G__2732] (.with ^java.time.LocalTime this2731 G__2732)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__2732)) (clojure.core/let [G__2732 ^"java.time.temporal.TemporalAdjuster" G__2732] (.with ^java.time.LocalTime this2731 G__2732)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn now {:arglists (quote ([] ["java.time.Clock"] ["java.time.ZoneId"]))} (^java.time.LocalTime [] (. java.time.LocalTime now)) (^java.time.LocalTime [G__2734] #? (:cljs (. java.time.LocalTime now G__2734) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__2734)) (clojure.core/let [G__2734 ^"java.time.Clock" G__2734] (. java.time.LocalTime now G__2734)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__2734)) (clojure.core/let [G__2734 ^"java.time.ZoneId" G__2734] (. java.time.LocalTime now G__2734)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn compare-to {:arglists (quote (["java.time.LocalTime" "java.time.LocalTime"] ["java.time.LocalTime" "java.lang.Object"]))} (^java.lang.Integer [this2735 G__2736] #? (:cljs (.compareTo ^java.time.LocalTime this2735 G__2736) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.LocalTime") G__2736)) (clojure.core/let [G__2736 ^"java.time.LocalTime" G__2736] (.compareTo ^java.time.LocalTime this2735 G__2736)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__2736)) (clojure.core/let [G__2736 ^"java.lang.Object" G__2736] (.compareTo ^java.time.LocalTime this2735 G__2736)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn to-nano-of-day {:arglists (quote (["java.time.LocalTime"]))} (^long [^java.time.LocalTime this2737] (.toNanoOfDay this2737)))
(clojure.core/defn plus-seconds {:arglists (quote (["java.time.LocalTime" "long"]))} (^java.time.LocalTime [^java.time.LocalTime this2738 ^long long2739] (.plusSeconds this2738 long2739)))
(clojure.core/defn get {:arglists (quote (["java.time.LocalTime" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.LocalTime this2740 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2741] (.get this2740 java-time-temporal-TemporalField2741)))
(clojure.core/defn of-second-of-day {:arglists (quote (["long"]))} (^java.time.LocalTime [^long long2742] (. java.time.LocalTime ofSecondOfDay long2742)))
(clojure.core/defn equals {:arglists (quote (["java.time.LocalTime" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.LocalTime this2743 ^java.lang.Object java-lang-Object2744] (.equals this2743 java-lang-Object2744)))
(clojure.core/defn format {:arglists (quote (["java.time.LocalTime" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.LocalTime this2745 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter2746] (.format this2745 java-time-format-DateTimeFormatter2746)))
