(ns cljc.java-time.instant (:require [cljs.java-time.interop :as jti] #? (:cljs [java.time :refer [Instant]])) (:refer-clojure :exclude [get range format min max next name resolve]) #? (:clj (:import [java.time Instant])))
(def min (. java.time.Instant -MIN))
(def epoch (. java.time.Instant -EPOCH))
(def max (. java.time.Instant -MAX))
(clojure.core/defn truncated-to {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalUnit"]))} (^java.time.Instant [^java.time.Instant this2393 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit2394] (.truncatedTo this2393 java-time-temporal-TemporalUnit2394)))
(clojure.core/defn range {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.Instant this2395 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2396] (.range this2395 java-time-temporal-TemporalField2396)))
(clojure.core/defn of-epoch-second {:arglists (quote (["long" "long"] ["long"]))} (^java.time.Instant [^long long2397 ^long long2398] (. java.time.Instant ofEpochSecond long2397 long2398)) (^java.time.Instant [^long long2399] (. java.time.Instant ofEpochSecond long2399)))
(clojure.core/defn at-offset {:arglists (quote (["java.time.Instant" "java.time.ZoneOffset"]))} (^java.time.OffsetDateTime [^java.time.Instant this2400 ^java.time.ZoneOffset java-time-ZoneOffset2401] (.atOffset this2400 java-time-ZoneOffset2401)))
(clojure.core/defn minus-millis {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this2402 ^long long2403] (.minusMillis this2402 long2403)))
(clojure.core/defn get-nano {:arglists (quote (["java.time.Instant"]))} (^java.lang.Integer [^java.time.Instant this2404] (jti/getter nano this2404)))
(clojure.core/defn plus-millis {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this2405 ^long long2406] (.plusMillis this2405 long2406)))
(clojure.core/defn minus-seconds {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this2407 ^long long2408] (.minusSeconds this2407 long2408)))
(clojure.core/defn plus-nanos {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this2409 ^long long2410] (.plusNanos this2409 long2410)))
(clojure.core/defn plus {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this2411 G__2412] #? (:cljs (.plus ^java.time.Instant this2411 G__2412) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2412)) (clojure.core/let [G__2412 ^"java.time.temporal.TemporalAmount" G__2412] (.plus ^java.time.Instant this2411 G__2412)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2412)) (clojure.core/let [G__2412 ^"java.time.temporal.TemporalAmount" G__2412] (.plus ^java.time.Instant this2411 G__2412)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this2413 G__2414 G__2415] #? (:cljs (.plus ^java.time.Instant this2413 G__2414 G__2415) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2414) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2415)) (clojure.core/let [G__2414 (clojure.core/long G__2414) G__2415 ^"java.time.temporal.TemporalUnit" G__2415] (.plus ^java.time.Instant this2413 G__2414 G__2415)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2414) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2415)) (clojure.core/let [G__2414 (clojure.core/long G__2414) G__2415 ^"java.time.temporal.TemporalUnit" G__2415] (.plus ^java.time.Instant this2413 G__2414 G__2415)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn query {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.Instant this2416 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery2417] (.query this2416 java-time-temporal-TemporalQuery2417)))
(clojure.core/defn to-string {:arglists (quote (["java.time.Instant"]))} (^java.lang.String [^java.time.Instant this2418] (.toString this2418)))
(clojure.core/defn is-before {:arglists (quote (["java.time.Instant" "java.time.Instant"]))} (^java.lang.Boolean [^java.time.Instant this2419 ^java.time.Instant java-time-Instant2420] (.isBefore this2419 java-time-Instant2420)))
(clojure.core/defn minus {:arglists (quote (["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this2421 G__2422 G__2423] #? (:cljs (.minus ^java.time.Instant this2421 G__2422 G__2423) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2422) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2423)) (clojure.core/let [G__2422 (clojure.core/long G__2422) G__2423 ^"java.time.temporal.TemporalUnit" G__2423] (.minus ^java.time.Instant this2421 G__2422 G__2423)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2422) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2423)) (clojure.core/let [G__2422 (clojure.core/long G__2422) G__2423 ^"java.time.temporal.TemporalUnit" G__2423] (.minus ^java.time.Instant this2421 G__2422 G__2423)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this2424 G__2425] #? (:cljs (.minus ^java.time.Instant this2424 G__2425) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2425)) (clojure.core/let [G__2425 ^"java.time.temporal.TemporalAmount" G__2425] (.minus ^java.time.Instant this2424 G__2425)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2425)) (clojure.core/let [G__2425 ^"java.time.temporal.TemporalAmount" G__2425] (.minus ^java.time.Instant this2424 G__2425)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn at-zone {:arglists (quote (["java.time.Instant" "java.time.ZoneId"]))} (^java.time.ZonedDateTime [^java.time.Instant this2426 ^java.time.ZoneId java-time-ZoneId2427] (.atZone this2426 java-time-ZoneId2427)))
(clojure.core/defn of-epoch-milli {:arglists (quote (["long"]))} (^java.time.Instant [^long long2428] (. java.time.Instant ofEpochMilli long2428)))
(clojure.core/defn get-long {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^long [^java.time.Instant this2429 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2430] (.getLong this2429 java-time-temporal-TemporalField2430)))
(clojure.core/defn until {:arglists (quote (["java.time.Instant" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.Instant this2431 ^java.time.temporal.Temporal java-time-temporal-Temporal2432 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit2433] (.until this2431 java-time-temporal-Temporal2432 java-time-temporal-TemporalUnit2433)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.Instant [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor2434] (. java.time.Instant from java-time-temporal-TemporalAccessor2434)))
(clojure.core/defn is-after {:arglists (quote (["java.time.Instant" "java.time.Instant"]))} (^java.lang.Boolean [^java.time.Instant this2435 ^java.time.Instant java-time-Instant2436] (.isAfter this2435 java-time-Instant2436)))
(clojure.core/defn minus-nanos {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this2437 ^long long2438] (.minusNanos this2437 long2438)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [this2439 G__2440] #? (:cljs (.isSupported ^java.time.Instant this2439 G__2440) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2440)) (clojure.core/let [G__2440 ^"java.time.temporal.TemporalUnit" G__2440] (.isSupported ^java.time.Instant this2439 G__2440)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2440)) (clojure.core/let [G__2440 ^"java.time.temporal.TemporalField" G__2440] (.isSupported ^java.time.Instant this2439 G__2440)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence"]))} (^java.time.Instant [^java.lang.CharSequence java-lang-CharSequence2441] (. java.time.Instant parse java-lang-CharSequence2441)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.Instant"]))} (^java.lang.Integer [^java.time.Instant this2442] (.hashCode this2442)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.Instant" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.Instant this2443 ^java.time.temporal.Temporal java-time-temporal-Temporal2444] (.adjustInto this2443 java-time-temporal-Temporal2444)))
(clojure.core/defn with {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalAdjuster"] ["java.time.Instant" "java.time.temporal.TemporalField" "long"] ["java.time.Instant" "java.time.temporal.TemporalAdjuster"] ["java.time.Instant" "java.time.temporal.TemporalField" "long"]))} (^java.lang.Object [this2445 G__2446] #? (:cljs (.with ^java.time.Instant this2445 G__2446) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__2446)) (clojure.core/let [G__2446 ^"java.time.temporal.TemporalAdjuster" G__2446] (.with ^java.time.Instant this2445 G__2446)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__2446)) (clojure.core/let [G__2446 ^"java.time.temporal.TemporalAdjuster" G__2446] (.with ^java.time.Instant this2445 G__2446)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this2447 G__2448 G__2449] #? (:cljs (.with ^java.time.Instant this2447 G__2448 G__2449) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2448) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2449)) (clojure.core/let [G__2448 ^"java.time.temporal.TemporalField" G__2448 G__2449 (clojure.core/long G__2449)] (.with ^java.time.Instant this2447 G__2448 G__2449)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2448) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2449)) (clojure.core/let [G__2448 ^"java.time.temporal.TemporalField" G__2448 G__2449 (clojure.core/long G__2449)] (.with ^java.time.Instant this2447 G__2448 G__2449)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn now {:arglists (quote ([] ["java.time.Clock"]))} (^java.time.Instant [] (. java.time.Instant now)) (^java.time.Instant [^java.time.Clock java-time-Clock2450] (. java.time.Instant now java-time-Clock2450)))
(clojure.core/defn to-epoch-milli {:arglists (quote (["java.time.Instant"]))} (^long [^java.time.Instant this2451] (.toEpochMilli this2451)))
(clojure.core/defn get-epoch-second {:arglists (quote (["java.time.Instant"]))} (^long [^java.time.Instant this2452] (jti/getter epochSecond this2452)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.Instant" "java.time.Instant"] ["java.time.Instant" "java.lang.Object"]))} (^java.lang.Integer [this2453 G__2454] #? (:cljs (.compareTo ^java.time.Instant this2453 G__2454) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Instant") G__2454)) (clojure.core/let [G__2454 ^"java.time.Instant" G__2454] (.compareTo ^java.time.Instant this2453 G__2454)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__2454)) (clojure.core/let [G__2454 ^"java.lang.Object" G__2454] (.compareTo ^java.time.Instant this2453 G__2454)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn plus-seconds {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this2455 ^long long2456] (.plusSeconds this2455 long2456)))
(clojure.core/defn get {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.Instant this2457 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2458] (.get this2457 java-time-temporal-TemporalField2458)))
(clojure.core/defn equals {:arglists (quote (["java.time.Instant" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.Instant this2459 ^java.lang.Object java-lang-Object2460] (.equals this2459 java-lang-Object2460)))
